一、nginx安装
1.这个已经在上篇进行说明，这里不详述

2.配置开机启动
在/etc/init.d/目录下创建 nginx 文件
vi /etc/init.d/nginx
拷贝以下内容
#!/bin/sh
#
# nginx - this script starts and stops the nginx daemon
#
# chkconfig:   - 85 15
# description:  Nginx is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /etc/nginx/nginx.conf
# config:      /etc/sysconfig/nginx
# pidfile:     /var/run/nginx.pid
# Source function library.
. /etc/rc.d/init.d/functions
# Source networking configuration.
. /etc/sysconfig/network
# Check that networking is up.
[ "$NETWORKING" = "no" ] && exit 0
nginx="/usr/sbin/nginx"
prog=$(basename $nginx)
sysconfig="/etc/sysconfig/$prog"
lockfile="/var/lock/subsys/nginx"
pidfile="/var/run/${prog}.pid"
NGINX_CONF_FILE="/etc/nginx/nginx.conf"
[ -f $sysconfig ] && . $sysconfig
start() {
    [ -x $nginx ] || exit 5
    [ -f $NGINX_CONF_FILE ] || exit 6
    echo -n $"Starting $prog: "
    daemon $nginx -c $NGINX_CONF_FILE
    retval=$?
    echo
    [ $retval -eq 0 ] && touch $lockfile
    return $retval
}
stop() {
    echo -n $"Stopping $prog: "
    killproc -p $pidfile $prog
    retval=$?
    echo
    [ $retval -eq 0 ] && rm -f $lockfile
    return $retval
}
restart() {
    configtest_q || return 6
    stop
    start
}
reload() {
    configtest_q || return 6
    echo -n $"Reloading $prog: "
    killproc -p $pidfile $prog -HUP
    echo
}
configtest() {
    $nginx -t -c $NGINX_CONF_FILE
}
configtest_q() {
    $nginx -t -q -c $NGINX_CONF_FILE
}
rh_status() {
    status $prog
}
rh_status_q() {
    rh_status >/dev/null 2>&1
}
# Upgrade the binary with no downtime.
upgrade() {
    local oldbin_pidfile="${pidfile}.oldbin"

    configtest_q || return 6
    echo -n $"Upgrading $prog: "
    killproc -p $pidfile $prog -USR2
    retval=$?
    sleep 1
    if [[ -f ${oldbin_pidfile} && -f ${pidfile} ]];  then
        killproc -p $oldbin_pidfile $prog -QUIT
        success $"$prog online upgrade"
        echo 
        return 0
    else
        failure $"$prog online upgrade"
        echo
        return 1
    fi
}
# Tell nginx to reopen logs
reopen_logs() {
    configtest_q || return 6
    echo -n $"Reopening $prog logs: "
    killproc -p $pidfile $prog -USR1
    retval=$?
    echo
    return $retval
}
case "$1" in
    start)
        rh_status_q && exit 0
        $1
        ;;
    stop)
        rh_status_q || exit 0
        $1
        ;;
    restart|configtest|reopen_logs)
        $1
        ;;
    force-reload|upgrade) 
        rh_status_q || exit 7
        upgrade
        ;;
    reload)
        rh_status_q || exit 7
        $1
        ;;
    status|status_q)
        rh_$1
        ;;
    condrestart|try-restart)
        rh_status_q || exit 7
        restart
        ;;
    *)
        echo $"Usage: $0 {start|stop|reload|configtest|status|force-reload|upgrade|restart|reopen_logs}"
        exit 2
esac

3.设置/etc/init.d/nginx 执行权限
chmod 777 /etc/init.d/nginx

4.设置开机默认启动
chkconfig --add nginx //添加系统服务
chkconfig --level 345 nginx on //设置开机启动,启动级别
chkconfig --list nginx //查看开机启动配置信息
5.nginx控制命令
service nginx start   #开启
service nginx stop    #停止
service nginx restart #重启
service nginx reload  #重新加载

6.编辑nginx conf文件
vim /etc/nginx/conf/nginx.conf
# nginx.conf
# the upstream component nginx needs to connect to
upstream pysharp {
     server unix:///project/pysharp/pysharp.sock; # for a file socket
    # server 127.0.0.1:8001; # for a web port socket (we'll use this first)
}
# configuration of the server
server {
    # the port your site will be served on
    listen      80;
    #listen      443  ssl;
    # the domain name it will serve for
    server_name test.cn; # substitute your machine's IP address or FQDN
    charset     utf-8;

    # max upload size
    client_max_body_size 75M;   # ad just to taste

    # Django media
    #location /media  {
    #    alias /path/to/your/mysite/media;  # your Django project's media files - amend as required
    #}

    location /static {     
         alias /project/pysharp/static; # your Django project's static files - amend as required
    }

    # Finally, send all non-media requests to the Django server.
    location / {
        uwsgi_pass  pysharp;
        include     /etc/nginx/uwsgi_params; # the uwsgi_params file you installed
    }
}

二、uwsgi安装
1.安装在上篇已说明，在此不详述
2.uwsgi配置 示例
在Django应用程序目录下创建deploy文件夹，加入uwsgi.ini文件
vim /project/pysharp/deploy/uwsgi.ini
拷贝以下内容
[uwsgi]
# Django-related settings
# the base directory (full path)
chdir       = /project/pysharp
# Django's wsgi file
module      = pysharp.wsgi
# the virtualenv (full path)
home        = /project/virtualenv/pysharp   #使用virtualenv
# plugin        = python
# process-related settings
# master
master      = true
# maximum number of worker processes
processes   = 10
# the socket 
socket      = /project/pysharp/pysharp.sock
pidfile    = /project/pysharp/pysharp.pid
# ... with appropriate permissions - may be needed
chmod-socket    = 666
# clear environment on exit
vacuum      = true

三、supervisor安装
1.安装不详述
2.创建默认的配置文件
echo_supervisord_conf  >/etc/supervisord.conf
3.配置开机启动
在/etc/init.d/目录下创建 supervisord 文件
vi /etc/init.d/supervisord
拷贝以下内容
#!/bin/bash
#
# supervisord   This scripts turns supervisord on
# chkconfig:    345 83 04
# description:  supervisor is a process control utility.  It has a web based
#     xmlrpc interface as well as a few other nifty features.
#
# source function library
. /etc/rc.d/init.d/functions
set -a
PREFIX=/usr/local/python2.7
SUPERVISORD=$PREFIX/bin/supervisord
SUPERVISORCTL=$PREFIX/bin/supervisorctl
PIDFILE=/var/supervisor/supervisord.pid
LOCKFILE=/var/supervisor/supervisord.lock
OPTIONS="-c /etc/supervisord.conf"
# unset this variable if you don't care to wait for child processes to shutdown before removing the $LOCKFILE-lock
WAIT_FOR_SUBPROCESSES=yes
# remove this if you manage number of open files in some other fashion
ulimit -n 96000
RETVAL=0
running_pid()
{
  # Check if a given process pid's cmdline matches a given name
  pid=$1
  name=$2
  [ -z "$pid" ] && return 1
  [ ! -d /proc/$pid ] && return 1
  (cat /proc/$pid/cmdline | tr "\000" "\n"|grep -q $name) || return 1
  return 0
}
running()
{
# Check if the process is running looking at /proc
# (works for all users)

  # No pidfile, probably no daemon present
  [ ! -f "$PIDFILE" ] && return 1
  # Obtain the pid and check it against the binary name
  pid=`cat $PIDFILE`
  running_pid $pid $SUPERVISORD || return 1
  return 0
}
start() {
    echo "Starting supervisord: "

    if [ -e $PIDFILE ]; then 
    echo "ALREADY STARTED"
    return 1
  fi
  # start supervisord with options from sysconfig (stuff like -c)
    $SUPERVISORD $OPTIONS
  # show initial startup status
  $SUPERVISORCTL $OPTIONS status
  # only create the subsyslock if we created the PIDFILE
    [ -e $PIDFILE ] && touch $LOCKFILE
}
stop() {
    echo -n "Stopping supervisord: "
    $SUPERVISORCTL $OPTIONS shutdown
  if [ -n "$WAIT_FOR_SUBPROCESSES" ]; then 
      echo "Waiting roughly 60 seconds for $PIDFILE to be removed after child processes exit"
      for sleep in  2 2 2 2 4 4 4 4 8 8 8 8 last; do
        if [ ! -e $PIDFILE ] ; then
          echo "Supervisord exited as expected in under $total_sleep seconds"
          break
        else
          if [[ $sleep -eq "last" ]] ; then
            echo "Supervisord still working on shutting down. We've waited roughly 60 seconds, we'll let it do its thing from here"
            return 1
          else
            sleep $sleep
            total_sleep=$(( $total_sleep + $sleep ))
          fi
        fi
      done
    fi
    # always remove the subsys. We might have waited a while, but just remove it at this point.
    rm -f $LOCKFILE
}
restart() {
    stop
    start
}
case "$1" in
  start)
    start
    RETVAL=$?
    ;;
  stop)
    stop
    RETVAL=$?
    ;;
  restart|force-reload)
    restart
    RETVAL=$?
    ;;
  reload)
    $SUPERVISORCTL $OPTIONS reload
    RETVAL=$?
    ;;
  condrestart)
    [ -f $LOCKFILE ] && restart
    RETVAL=$?
    ;;
  status)
    $SUPERVISORCTL $OPTIONS status
    if running ; then
      RETVAL=0
    else
      RETVAL=1
    fi
    ;;
  *)
    echo $"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart}"
    exit 1
esac

exit $RETVAL

4.设置/etc/init.d/supervisord 执行权限
chmod 777 /etc/init.d/supervisord
设置开机默认启动
chkconfig --add supervisord //添加系统服务
chkconfig --level 345 supervisord on //设置开机启动,启动级别
在/etc/supervisord.conf 的末尾加上
[include]
files = /etc/supervisor/conf.d/*.conf
创建配置文件目录
mkdir /etc/supervisor/conf.d

5.应用程序进程管理配置 示例
vim /etc/supervisor/conf.d/uwsgi_start.conf
拷贝以下内容
; ================================
;  uwsgi supervisor
; ================================

[program:uwsgi_pysharp]
command=/usr/local/bin/uwsgi --ini /project/pysharp/deploy/uwsgi.ini
directory=/project/pysharp/deploy
user=root
numprocs=1
stdout_logfile=/var/log/django/uwsgi_start.log  #需要先手动创建文件夹
stderr_logfile=/var/log/django/uwsgi_start.log
autostart=true
autorestart=true
startsecs=10
priority=997

6.supervisor控制命令
supervisorctl status  #查看进程运行状态
supervisorctl reload  #重新加载配置

四、wsgi.py文件
"""
WSGI config for wictrl project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os
import sys

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "my_blog.settings")
sys.path.append('/usr/local/lib/python2.7/site-packages')  
# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application

application = get_wsgi_application()


# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

